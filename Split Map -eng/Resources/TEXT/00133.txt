--[[--CTF/Lua v3.0--By Darren Watts (W'rkncacnter)--Updates by Jon Irons, changes by Bill Catambay to integrate into EMR--]]ctf_idle = idle;ctf_got_item = got_item;ctf_cleanup = cleanup;to={};to.pdeg = 360/512;to.wu = 1/1024;HORIZ = 10;VERT = 45;facerName = "";theFaced = local_player_index();team1_flag = nil --Polygon of team 1's flagteam2_flag = nil --Polygon of team 2's flagteam1_bases = {} --Polygons for team1team2_bases = {} --Polygons for team2teams = {}team1_flag_in_base = trueteam2_flag_in_base = trueplayer_has_flag = {}count1 = 0count2 = 0wait = 1original_teams = {}original_colors = {}team1_color = 1team2_color = 6carrier_color = 4finish_off = falsehas_ended = falseholder_death_checked = {}current_captures = {}distance = {}flag_position = {} -- first 3 elements are team 1's x, y, z. Next three are coords for team 2's flag.reset_timer = {}RESET_AMOUNT = 1350err = "This is not a valid CTF map.  The readme provides information for hosting CTF games."--[[ ----------------  Icons ---------------------]]icons = {};colors = {};colors.team1 = [[3#5e2605&ff0000%111111]]colors.team2 = [[3#5E2605&0000FF%111111]]icons.carrying = [[%##&%%%%%%%&&&&%%##&&&%%%&&&&&&%%##&&&&&&&&&&&&%%##&&&&&&&&&&&&%###&&&&&&&&&&&&%##&&&&&&&&&&&&&%##&&&&&&&&&&&&&%##%%&&&&&&&%%%%%##%%%%&&&%%%%%%%##%%%%%%%%%%%%%%##%%%%%%%%%%%%%%##%%%%%%%%%%%%%%#%%%%%%%%%%%%%%%#%%%%%%%%%%%%%%%#%%%%%%%%%%%%%%%#%%%%%%%%%%%%%%%]]icons.dropped = [[&&%%%%%%%%%%%%&&&&&%%%%%%%%%%&&&%&&&%%%%%%%%&&&%%%&&&%%%%%%&&&%%%%%&&&%%%%&&&%%%%%%%&&&%%&&&%%%%%%%%%&&&&&&%%%%%%%%%%%&&&&%%%%%%%%%%%%&&&&%%%%%%%%%%%&&&&&&%%%%%%%%%&&&%%&&&%%%%%%%&&&%%%%&&&%%%%%&&&%%%%%%&&&%%%&&&%%%%%%%%&&&%&&&%%%%%%%%%%&&&&&%%%%%%%%%%%%&&]]icons.notcarrying = [[%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%]]function init()   if get_game_type() ~= _game_of_capture_the_flag then      return;      end   initialize_vars()   set_base_polys()   check_teams()   place_flags()endfunction initialize_vars()	for i = 1, number_of_players(), 1 do		player_has_flag[i] = false		holder_death_checked[i+1] = true		end	for i = 0, number_of_players(), 1 do		distance[i+1] = 0		end	for i = 1, 6, 1 do		flag_position[i] = 0		end	current_captures[1] = 0	current_captures[2] = 0	reset_timer[1] = 0	reset_timer[2] = 0endfunction set_base_polys()	for text,polygon,x,y in annotations() do		if(string.lower(text) == "rf") then			team1_flag = polygon			end		if(string.lower(text) == "bf") then			team2_flag = polygon			end		if(string.lower(text) == "rb") then			team1_bases[table.getn(team1_bases) + 1] = polygon			end		if(string.lower(text) == "bb") then			team2_bases[table.getn(team2_bases) + 1] = polygon			end		end	if(team1_flag == nil) or (team2_flag == nil) or (table.getn(team1_bases) == 0) or	  (table.getn(team2_bases) == 0) then		set_base_polys2()		endendfunction set_base_polys2()	if (team1_flag == nil) then		for i = 0, number_of_polygons() - 1, 1 do			if(get_polygon_type(i) == _polygon_is_visible_monster_trigger) then				team1_flag = i				end			end		end	if (team2_flag == nil) then		for i = 0, number_of_polygons() - 1, 1 do			if(get_polygon_type(i) == _polygon_is_invisible_monster_trigger) then				team2_flag = i				end			end		end	if (table.getn(team1_bases) == 0) then		for i = 0, number_of_polygons() - 1, 1 do			if(get_polygon_type(i) == _polygon_is_dual_monster_trigger) then				team1_bases[table.getn(team1_bases) + 1] = i				end			end		end	if (table.getn(team2_bases) == 0) then		for i = 0, number_of_polygons() - 1, 1 do			if(get_polygon_type(i) == _polygon_must_be_explored) then				team2_bases[table.getn(team2_bases) + 1] = i				end			end		endendfunction check_teams()	local red_team_exists = false	local blue_team_exists = false	for i = 0, number_of_players() - 1, 1 do		if(get_player_team(i) == team1_color) then			red_team_exists = true		elseif(get_player_team(i) == team2_color) then			blue_team_exists = true			end		end	if (red_team_exists == false and blue_team_exists == false) then		assign_teams(0)	elseif (red_team_exists == true and blue_team_exists == false) then		assign_teams(1)	elseif (red_team_exists == false and blue_team_exists == true) then		assign_teams(2)	else		assign_teams(3)		endendfunction assign_teams(num)	if (num == 0) then		num = math.mod (better_random (), number_of_players())		teams[1] = get_player_team(num)		for i = 0, number_of_players() - 1, 1 do --Split into teams.			if (get_player_team(i) ~= teams[1]) then				teams[table.getn(teams) + 1] = get_player_team(i)				end			end		for i = 0, number_of_players() - 1, 1 do			if (get_player_team(i) == teams[1]) then				set_player_team(i, team1_color)				set_player_color(i, team1_color)				original_teams[i+1] = team1_color				original_colors[i+1] = get_player_color(i)			else				set_player_team(i, team2_color)				set_player_color(i, team2_color)				original_teams[i+1] = team2_color				original_colors[i+1] = get_player_color(i)				end			end		end	if (num == 1 or num == 3) then		for i = 0, number_of_players() - 1, 1 do			if (get_player_team(i) == team1_color) then				set_player_team(i, team1_color)				set_player_color(i, team1_color)				original_teams[i+1] = team1_color				original_colors[i+1] = get_player_color(i)			else				set_player_team(i, team2_color)				set_player_color(i, team2_color)				original_teams[i+1] = team2_color				original_colors[i+1] = get_player_color(i)				end			end		end	if (num == 2) then		for i = 0, number_of_players() - 1, 1 do			if(get_player_team(i) == team2_color) then				set_player_team(i, team2_color)				set_player_color(i, team2_color)				original_teams[i+1] = team2_color				original_colors[i+1] = get_player_color(i)			else				set_player_team(i, team1_color)				set_player_color(i, team1_color)				original_teams[i+1] = team1_color				original_colors[i+1] = get_player_color(i)				end			end		end	teams[1] = team1_color	teams[2] = team2_colorendfunction players_to_bases()	for i = 0, number_of_players() - 1, 1 do		to_base(i, 0)		endendfunction place_flags()	new_item (_item_uplink_chip, team1_flag)	new_item (_item_spht_door_key, team2_flag)endfunction idle()   ctf_idle();   if get_game_type() ~= _game_of_capture_the_flag then      return;      end	if (team1_flag == nil) or (team2_flag == nil) or 	   (table.getn(team1_bases) == 0) or (table.getn(team2_bases) == 0) then 		screen_print(err) 		for i = 0, 5, 1 do 			screen_print(" ") 			end		return		end	if(wait == 0) then		players_to_bases()		end	remove_skulls()  [[-- If they exist --]]	get_local_facing()	check_reset()	use_oxygen()	use_overlay()	check_player_land_location()	captured_flag()	update_count()	make_sure_flag_exists()	carrier_flash()	compass_on()endfunction remove_skulls()	for i = 0, MAXIMUM_OBJECTS_PER_MAP - 1, 1 do		if (item_index_valid(i)) then			if (get_item_type(i) == _item_red_ball) or (get_item_type(i) == _item_blue_ball) then				delete_item(i)				end			end		endendfunction check_reset()	local team1_player = nil	local team2_player = nil	for a = 0, number_of_players() - 1, 1 do		if (original_teams[a+1] == teams[1]) then			team1_player = a			break			end		end	for b = 0, number_of_players() - 1, 1 do		if (original_teams[b+1] == teams[2]) then			team2_player = b			break			end		end	if (reset_timer[1] == 1) then		for i = 0, MAXIMUM_OBJECTS_PER_MAP-1, 1 do			if (item_index_valid(i)) then				if (get_item_type(i) == _item_uplink_chip) then					delete_item(i)					end				end			end		save_flag(team1_player)		end	if (reset_timer[2] == 1) then		for i = 0, MAXIMUM_OBJECTS_PER_MAP-1, 1 do			if (item_index_valid(i)) then				if (get_item_type(i) == _item_spht_door_key) then					delete_item(i)					end				end			end		save_flag(team2_player)		endendfunction distance_from_player(player, ix, iy, iz)	local px, py, pz = get_player_position(player);	theDistance = math.sqrt((ix - px)^2 + (iy - py)^2 + (iz - pz)^2);	return theDistance;endfunction use_oxygen()	if (team1_flag_in_base) then		flag_position[1], flag_position[2] = get_polygon_center(team1_flag)		flag_position[1] = flag_position[1] / 1024		flag_position[2] = flag_position[2] / 1024		flag_position[3] = flag_position[3] / 1024		end	for p = 0, number_of_players() - 1, 1 do --If team 2 has flag.		if (player_has_flag[p+1] and original_teams[p+1] == teams[2]) then			flag_position[1], flag_position[2], flag_position[3] = get_player_position(p)			end		end	if (team2_flag_in_base) then		flag_position[4], flag_position[5] = get_polygon_center(team2_flag)		flag_position[4] = flag_position[4] / 1024		flag_position[5] = flag_position[5] / 1024		flag_position[6] = flag_position[6] / 1024		end	for p = 0, number_of_players() - 1, 1 do --If team 1 has flag.		if (player_has_flag[p+1] and original_teams[p+1] == teams[1]) then			flag_position[4], flag_position[5], flag_position[6] = get_player_position(p)			end		end	for i = 0, number_of_players() - 1, 1 do		if (original_teams[i+1] == teams[1]) then			distance[i+1] = distance_from_player(				i, flag_position[4], flag_position[5], flag_position[6])		else			distance[i+1] = distance_from_player(				i, flag_position[1], flag_position[2], flag_position[3])			end		end	local temp	for i = 0, number_of_players() - 1, 1 do		temp = 40 - distance[i+1]		if (temp < 0) then 			set_oxygen(i, 0)		else			set_oxygen(i, ( temp / 40 ) * 10800)			end		endendfunction use_overlay()	local team1_has_flag = false	local team2_has_flag = false	for i = 0, number_of_players() - 1, 1 do		if (original_teams[i+1] == teams[1] and player_has_flag[i+1]) then			team1_has_flag = true		elseif (original_teams[i+1] == teams[2] and player_has_flag[i+1]) then			team2_has_flag = true			end		end	set_overlay_color(0, 2)	set_overlay_text(0, current_captures[1] .. " / " .. get_kill_limit())	if (team1_has_flag) then		icon0 = colors.team2 .. icons.carrying;	elseif (team1_has_flag == false and team2_flag_in_base == false) then		icon0 = colors.team2 .. icons.dropped;	elseif (team2_flag_in_base) then		icon0 = colors.team2 .. icons.notcarrying;		end	set_overlay_icon(0, icon0);	set_overlay_color(1, 7)	set_overlay_text(1, current_captures[2] .. " / " .. get_kill_limit())	if (team2_has_flag) then		icon1 = colors.team1 .. icons.carrying;	elseif (team2_has_flag == false and team1_flag_in_base == false) then		icon1 = colors.team1 .. icons.dropped;	elseif (team1_flag_in_base) then		icon1 = colors.team1 .. icons.notcarrying;		end	set_overlay_icon(1, icon1);	set_overlay_color(2, 0);	local theOverlay = facerName;	if (player_has_flag[theFaced+1]) then		set_overlay_color(2, 5);		end	local fPercent = math.floor(100 * (get_life(theFaced)/150));	if (theFaced ~= local_player_index()) then		theOverlay = theOverlay.." ("..fPercent.."%)";		end	set_overlay_text(2, "      "..theOverlay);endfunction check_player_land_location()	for i = 0, number_of_players() - 1, 1 do		if (player_has_flag[i+1] and original_teams[i+1] == teams[1]) then			local a1, b1, c1 = get_player_external_velocity(i)			local x1, y1, z1 = get_player_position(i)			if (player_is_dead(i) and c1 == 0 and holder_death_checked[i+1]) then				for p = 0, number_of_players() - 1, 1 do					if (original_teams[p+1] == teams[2]) then						set_lua_compass_beacon (p, x1, y1)						set_lua_compass_state (p, _network_compass_use_beacon)						use_lua_compass(p, true)						flag_position[4] = x1						flag_position[5] = y1						flag_position[6] = z1						end					end				holder_death_checked[i+1] = false				player_has_flag[i+1] = false				set_player_color(i, original_colors[i+1])				end			end		if (player_has_flag[i+1] and original_teams[i+1] == teams[2]) then			local a2, b2, c2 = get_player_external_velocity(i)			local x2, y2, z2 = get_player_position(i)			if (player_is_dead(i) and c2 == 0 and holder_death_checked[i+1]) then				for p = 0, number_of_players() - 1, 1 do					if (original_teams[p+1] == teams[1]) then						set_lua_compass_beacon (p, x2, y2)						set_lua_compass_state (p, _network_compass_use_beacon)						use_lua_compass(p, true)						flag_position[1] = x2						flag_position[2] = y2						flag_position[3] = z2						end					end				holder_death_checked[i+1] = false				player_has_flag[i+1] = false				set_player_color(i, original_colors[i+1])				end			end		endendfunction captured_flag()	for i = 0, number_of_players() - 1, 1 do		if (original_teams[i+1] == teams[1]) then			if (player_has_flag[i+1] == true) and (get_player_polygon(i) == team1_flag) and			   (team1_flag_in_base) and (not player_is_dead(i)) then				set_player_color(i, original_colors[i+1])				player_has_flag[i+1] = false				team2_flag_in_base = true				current_captures[1] = current_captures[1] + 1				remove_item (i, _item_spht_door_key)				award_points (i, 1)				alert_captured(i, 1)				end		else			if (player_has_flag[i+1] == true) and (get_player_polygon(i) == team2_flag) and			   (team2_flag_in_base) and (not player_is_dead(i)) then				set_player_color(i, original_colors[i+1])				player_has_flag[i+1] = false				team1_flag_in_base = true				current_captures[2] = current_captures[2] + 1				remove_item (i, _item_uplink_chip)				award_points (i, 1)				alert_captured(i, 2)				end			end		endendfunction alert_captured(player, num)	if (num == 1) then		for i = 0, number_of_players() - 1, 1 do			if (original_teams[i+1] == teams[1] and i == player) then				screen_print(i, "You have captured the enemy flag!")			elseif (original_teams[i+1] == teams[1] and i ~= player) then				screen_print(i, "Your team has captured the enemy flag!")			elseif (original_teams[i+1] == teams[2]) then				screen_print(i, "The enemy has captured your flag!")				end			end	else		for i = 0, number_of_players() - 1, 1 do			if (original_teams[i+1] == teams[2] and i == player) then				screen_print(i, "You have captured the enemy flag!")			elseif (original_teams[i+1] == teams[2] and i ~= player) then				screen_print(i, "Your team has captured the enemy flag!")			elseif (original_teams[i+1] == teams[1]) then				screen_print(i, "The enemy has captured your flag!")				end			end		endendfunction update_count()	if (count1 > 0) then		count1 = count1 - 1		end	if (count2 > 0) then		count2 = count2 - 1		end	if (wait >= -1) then		wait = wait - 1		end	if (reset_timer[1] > 0) then		reset_timer[1] = reset_timer[1] - 1		end	if (reset_timer[2] > 0) then		reset_timer[2] = reset_timer[2] - 1		endendfunction make_sure_flag_exists()	local flag1exists = false	local flag2exists = false	for i = 0, MAXIMUM_OBJECTS_PER_MAP-1, 1 do		if (item_index_valid(i)) then			if (get_item_type(i) == _item_uplink_chip) then				flag1exists = true			elseif (get_item_type(i) == _item_spht_door_key) then				flag2exists = true				end			end		end	if (flag1exists == false and team1_flag_in_base == true and count1 <= 0) then		new_item (_item_uplink_chip, team1_flag)		count1 = 10		end	if (flag2exists == false and team2_flag_in_base == true and count2 <= 0) then		new_item (_item_spht_door_key, team2_flag)		count2 = 10		endendfunction carrier_flash()	for i = 0, number_of_players() - 1, 1 do		if (player_has_flag[i+1] == true) then			set_player_color(i, carrier_color);			end		endendfunction compass_on()	local team1_has_flag = false	local team2_has_flag = false	local carrier_team1 = nil	local carrier_team2 = nil	for i = 0, number_of_players() - 1, 1 do		if (player_has_flag[i+1] == true) then			if (original_teams[i+1] == teams[1]) then				carrier_team1 = i				team1_has_flag = true			else				carrier_team2 = i				team2_has_flag = true				end			end		end	for i = 0, number_of_players() - 1, 1 do		if (original_teams[i+1] == teams[1]) then			if (team2_has_flag == true) then				x, y, z = get_player_position(carrier_team2)				set_lua_compass_beacon (i, x, y)				set_lua_compass_state (i, _network_compass_use_beacon)				use_lua_compass(i, true)				end			end		if (original_teams[i+1] == teams[2]) then			if (team1_has_flag == true) then				x, y, z = get_player_position(carrier_team1)				set_lua_compass_beacon (i, x, y)				set_lua_compass_state (i, _network_compass_use_beacon)				use_lua_compass(i, true)				end			end		if (player_has_flag[i+1] == false and original_teams[i+1] == teams[2]) then			if (team1_has_flag == true) then				x, y, z = get_player_position(carrier_team1)				set_lua_compass_beacon (i, x, y)				set_lua_compass_state (i, _network_compass_use_beacon)				use_lua_compass(i, true)				end			end		if (team1_flag_in_base == true) then			if (original_teams[i+1] == teams[1] and not player_has_flag[i+1]) then 				use_lua_compass(i, false)				end			end		if (team2_flag_in_base == true) then			if (original_teams[i+1] == teams[2] and not player_has_flag[i+1]) then 				use_lua_compass(i, false)				end			end		if (player_has_flag[i+1] and original_teams[i+1] == teams[1] and team1_flag_in_base) then			x, y, z = get_polygon_center(team1_flag)			x = x / 1024 y = y / 1024			set_lua_compass_beacon(i, x, y)			set_lua_compass_state(i, _network_compass_use_beacon)			use_lua_compass(i, true)			end		if (player_has_flag[i+1] and original_teams[i+1] == teams[2] and team2_flag_in_base) then			x, y, z = get_polygon_center(team2_flag)			x = x / 1024 y = y / 1024			set_lua_compass_beacon(i, x, y)			set_lua_compass_state(i, _network_compass_use_beacon)			use_lua_compass(i, true)			end		endendfunction got_item(type, player)   ctf_got_item(type, player);   if get_game_type() ~= _game_of_capture_the_flag then      return;      end	if (original_teams[player+1] == teams[1]) then		if (type == _item_spht_door_key) then			player_has_flag[player+1] = true			alert_teams(1)			team2_flag_in_base = false			holder_death_checked[player+1] = true			reset_timer[2] = 0			end		if (type == _item_uplink_chip and team1_flag_in_base == true) then			deny_pickup(player)			end		if (type == _item_uplink_chip and team1_flag_in_base == false) then			save_flag(player)			reset_timer[1] = 0			end	elseif (original_teams[player+1] == teams[2]) then		if (type == _item_uplink_chip) then			player_has_flag[player+1] = true			alert_teams(2)			team1_flag_in_base = false			holder_death_checked[player+1] = true			reset_timer[1] = 0			end		if (type == _item_spht_door_key and team2_flag_in_base == true) then			deny_pickup(player)			end		if (type == _item_spht_door_key and team2_flag_in_base == false) then			save_flag(player)			reset_timer[2] = 0			end		endendfunction alert_teams(num)	if (num == 1) then		for i = 0, number_of_players() - 1, 1 do			if (original_teams[i+1] == teams[1] and player_has_flag[i+1] == true) then				screen_print(i, "You have the enemy flag!")			elseif (original_teams[i+1] == teams[1] and player_has_flag[i+1] == false) then				screen_print(i, "Your team has the enemy flag!")			elseif (original_teams[i+1] == teams[2]) then				screen_print(i, "Your flag has been taken!")				play_sound(i, _snd_alarm, 1)				end			end	else		for i = 0, number_of_players() - 1, 1 do			if (original_teams[i+1] == teams[2] and player_has_flag[i+1] == true) then				screen_print(i, "You have the enemy flag!")			elseif (original_teams[i+1] == teams[2] and player_has_flag[i+1] == false) then				screen_print(i, "Your team has the enemy flag!")			elseif (original_teams[i+1] == teams[1]) then				screen_print(i, "Your flag has been taken!")				play_sound(i, _snd_alarm, 1)				end			end		endendfunction to_base(player, num_tried)	if (num_tried < 11) then		if original_teams[player+1] == teams[1] then			local poly_has_player = false			local poly = math.mod (better_random (), table.getn(team1_bases))			if (num_tried >= 10) then				teleport_player(player, team1_bases[poly+1])				end			for i = 0, number_of_players() - 1, 1 do				if (get_player_polygon(i) == team1_bases[poly+1]) then					poly_has_player = true					break					end				end			if (poly_has_player == false) then				teleport_player(player, team1_bases[poly+1])			else				to_base(player, num_tried + 1)				end		else			local poly_has_player = false			local poly = math.mod (better_random (), table.getn(team2_bases))			if (num_tried >= 10) then				teleport_player(player, team2_bases[poly+1])				end			for i = 0, number_of_players() - 1, 1 do				if (get_player_polygon(i) == team2_bases[poly+1]) then					poly_has_player = true					break					end				end			if (poly_has_player == false) then				teleport_player(player, team2_bases[poly+1])			else				to_base(player, num_tried + 1)				end			end		endendfunction player_killed(player, aggressor_player, action, projectile)	if (original_teams[player+1] == teams[1] and player_has_flag[player+1])then		reset_timer[2] = RESET_AMOUNT		end	if (original_teams[player+1] == teams[2] and player_has_flag[player+1])then		reset_timer[1] = RESET_AMOUNT		endendfunction player_revived(player)	if (get_player_color(player) == carrier_color and player_has_flag[player+1]) then		set_player_color(player, original_teams[player+1])		player_has_flag[player+1] = false		end	to_base(player, 0)endfunction deny_pickup(player)	if (original_teams[player+1] == teams[1]) then		remove_item(player, _item_uplink_chip)	else		remove_item(player, _item_spht_door_key)		endendfunction save_flag(player)	if (original_teams[player+1] == teams[1]) then		new_item (_item_uplink_chip, team1_flag)		team1_flag_in_base = true		remove_item(player, _item_uplink_chip)		save_flag_message(1)	else		new_item (_item_spht_door_key, team2_flag)		team2_flag_in_base = true		remove_item(player, _item_spht_door_key)		save_flag_message(2)		endendfunction save_flag_message(num)	if (num == 1) then		for i = 0, number_of_players() - 1, 1 do			if (original_teams[i+1] == teams[1]) then				screen_print(i, "Your flag has been returned!")			elseif(original_teams[i+1] == teams[2]) then				screen_print(i, "The enemy's flag was returned!")				end			end	else		for i = 0, number_of_players() - 1, 1 do			if (original_teams[i+1] == teams[2]) then				screen_print(i, "Your flag has been returned!")			elseif (original_teams[i+1] == teams[1]) then				screen_print(i, "The enemy's flag was returned!")				end			end		endendfunction cleanup()   ctf_cleanup();	for i = 0, number_of_players() - 1, 1 do		set_player_color(i, original_colors[i+1])		set_player_team(i, original_teams[i+1])		endend--[[Begin code by Jon Irons for determining which player one is facing]]function get_local_facing()	local a = player_to_monster_index(local_player_index());	if (monster_index_valid(a)) then		if (monster_to_player(a)) then			local facing_table = {};			local b;			for b=0, MAXIMUM_MONSTERS_PER_MAP-1, 1 do				if (a ~= b and monster_index_valid(b)) then					local monster_player = monster_to_player(b);					if is_monster_facing(a, b) and monster_player and 					   (not player_is_dead(monster_player)) then						facing_table[table.getn(facing_table) + 1] = b;						end					end				end			if (facing_table[1]) then				local most_close = closest_monster_to(a, facing_table);				local mc_pl = monster_to_player(most_close);				if most_close and 				   (get_player_team(mc_pl) == get_player_team(local_player_index())) then					theFaced = mc_pl;					facerName = get_player_name(theFaced);					end			else				facerName = "";				theFaced = local_player_index();				end			end		endendfunction is_monster_facing(m1, m2)	local x1, y1, z1 = get_monster_position(m1);	local yaw1, pitch1 = get_player_angle(monster_to_player(m1));	local x2, y2, z2 = get_monster_position(m2);	local yaw2, pitch2 = get_monster_facing(m2);	local distance = to.wu * math.sqrt((x1 - x2)^2 + (y1 - y2)^2);	local x = -1 * to.wu * (x2 - x1);	local y = to.wu * (y2 - y1);	local m1angle = yaw1;	local m2angle =  math.deg(math.atan2(y, x));	m2angle = math.abs(m2angle - 180);	if (true) then		if (angle_distance(m1angle, m2angle) <= HORIZ) then			return true;		else			return false;			end		endendfunction closest_monster_to(monster, monster_list)	local ggg;	local dist1;	local cdist = 999999999;	local cindex = nil;	local mindex = nil;	for ggg = 1, table.getn(monster_list), 1 do		local dude = monster_list[ggg];		local dudePl = monster_to_player(dude);		local plLive;		if (dudePl) then			plDead = player_is_dead(dudePl);			end		if (monster_index_valid(dude) and dude ~= monster and dudePl and not plDead) then			local x1, y1, z1 = get_monster_position(monster);			local x2, y2, z2 = get_monster_position(dude);			dist1 = math.sqrt((x1 - x2)^2 + (y1 - y2)^2);			if (dist1 < cdist) then				cdist = dist1;				cindex = dude;				end			end		end	return cindex;	endfunction monster_to_player(mon)	local h = nil;	for i=0, number_of_players()-1, 1 do		if (player_to_monster_index(i) == mon and monster_index_valid(mon)) then			h = i;			end		end	return h;end--[[end Irons code]]function angle_distance(angle1, angle2) --[[code by Solra Bizna]] 	--[[ Normalize the angles. ]] 	while angle1 < 0 do  		angle1 = angle1 + 360  		end	while angle1 >= 360 do 		angle1 = angle1 - 360 		end 	while angle2 < 0 do  		angle2 = angle2 + 360  		end	while angle2 >= 360 do 		angle2 = angle2 - 360 		end	 --[[ Subtract the angles. ]]	return math.abs(angle1 - angle2)end